// Inspired by http://jonbho.net/2013/08/26/spacecrash-day-1-of-7-game-skeleton/

#include "Assert.h"
#include "Color.h"
#include "Matrix44.h"
#include "MathUtils.h"
#include "Quaternion.h"
#include "SoftwareRenderer.h"
#include "Vector3.h"
#include "Vertex.h"

#include "stdafx.h"
#include "base.h"
#include "sys.h"

using namespace omb;

GLuint openGLTexId = 1;
SoftwareRenderer renderer;
uint16_t avatarTexId;
const dword width_pow2 = 512;
const dword height_pow2 = 512;
const dword width = 512;
const sdword height = 512;
float rotationDeg = 0;
float scale = 1.0f;
Vector3f posOffset(0, 0, 0);
bool usePerspective = false;
bool keyPressedLastFrame = false;

//-----------------------------------------------------------------------------
void StartGame()
{
	renderer.init(width, height);
	avatarTexId = renderer.loadTexture("Resources/avatar.png");
	
	glGenTextures(1, &openGLTexId);
	glBindTexture(GL_TEXTURE_2D, openGLTexId);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width_pow2, height_pow2, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
}

//-----------------------------------------------------------------------------
void EndGame()
{
	glDeleteTextures(1, &openGLTexId);
	
	renderer.unloadTexture(avatarTexId);
}

//-----------------------------------------------------------------------------
void Render()
{
	//glClear(GL_COLOR_BUFFER_BIT); // Not necessary, as the image generated by SoftwareRenderer will be fullscreen
	renderer.clear(omb::Color(0, 0, 0, 255));
	
	// Perspective matrix
	const float frustumScale = 1.0f;
	const float zNear = 0.5f;
	const float zFar = 3.0f;
	Matrix44 persMatrix;
	persMatrix(0, 0) = frustumScale;
	persMatrix(1, 1) = frustumScale;
	persMatrix(2, 2) = (zFar + zNear) / (zNear - zFar);
	persMatrix(2, 3) = (2 * zFar * zNear) / (zNear - zFar);
	persMatrix(3, 2) = -1.0f;
	
	const Matrix44 scaleMatrix = MathUtils::CreateScaleMatrix(scale);
	
	const Matrix44 translationMatrix = MathUtils::CreateTranslationMatrix(posOffset.x, posOffset.y, posOffset.z);
	
	Quaternion rotationTrans(Vector3f(0, 0, 1.0f), MathUtils::DegToRad(rotationDeg));
	const Matrix44 rotationMatrix = rotationTrans;
	
	std::vector<Vertex> vertices;
	/*vertices.push_back(Vertex(Vector4f(-1.0f, 0, 0), Color(colorValue, 0, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0, 0, 0), Color(colorValue, 0, 0, 255)));
	vertices.push_back(Vertex(Vector4f(-0.5f, -1.0f, 0), Color(colorValue, 0, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0.5f, -1.0f, 0), Color(colorValue, 0, 0, 255)));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.5f, -1.0f, 0), Color(0, colorValue, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0, 0, 0), Color(0, colorValue, 0, 255)));
	vertices.push_back(Vertex(Vector4f(1.0f, 0, 0), Color(0, colorValue, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0.5f, 1.0f, 0), Color(0, colorValue, 0, 255)));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.5f, 1.0f, 0), Color(0, 0, colorValue, 255)));
	vertices.push_back(Vertex(Vector4f(0, 0, 0), Color(0, 0, colorValue, 255)));
	vertices.push_back(Vertex(Vector4f(-0.5f, 1.0f, 0), Color(0, 0, colorValue, 255)));
	vertices.push_back(Vertex(Vector4f(-1.0f, 0, 0), Color(0, 0, colorValue, 255)));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);*/
	
	/*vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, 0), Color(255, 0, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.3f, 0), Color(0, 255, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0, -0.5f, 0), Color(0, 0, 255, 255)));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);*/
	
	// Beautiful triangle
	/*vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, 0), Color(255, 0, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, 0), Color(0, 255, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0, -0.5f, 0), Color(0, 0, 255, 255)));*/
	/*vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, 0), Color(255, 0, 0, 255)));
	vertices.push_back(Vertex(Vector4f(0, -0.5f, 0), Color(0, 0, 255, 255)));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, 0), Color(0, 255, 0, 255)));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);*/
	
	const Vector4f offset(0, 0, 0, 0);
	
	// Cube
	const Color red(255, 0, 0, 255);
	const Color green(0, 255, 0, 255);
	const Color blue(0, 0, 255, 255);
	const Color yellow(255, 255, 0, 255);
	const Color orange(255, 69, 0, 255);
	const Color pink(255, 20, 147, 255);
	// Front
	/*vertices.push_back(Vertex(Vector4f(-0.5f, -0.5f, 0.5f) + offset, red));
	vertices.push_back(Vertex(Vector4f(0.5f, -0.5f, 0.5f) + offset, red));
	vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, 0.5f) + offset, red));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, 0.5f) + offset, red));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	// Top
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, 0.5f) + offset, blue));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, 0.5f) + offset, blue));
	vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, -0.5f) + offset, blue));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, -0.5f) + offset, blue));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	// Back
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.5f, -0.5f, -0.5f) + offset, green));
	vertices.push_back(Vertex(Vector4f(-0.5f, -0.5f, -0.5f) + offset, green));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, -0.5f) + offset, green));
	vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, -0.5f) + offset, green));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	// Bottom
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(-0.5f, -0.5f, -0.5f) + offset, yellow));
	vertices.push_back(Vertex(Vector4f(0.5f, -0.5f, -0.5f) + offset, yellow));
	vertices.push_back(Vertex(Vector4f(-0.5f, -0.5f, 0.5f) + offset, yellow));
	vertices.push_back(Vertex(Vector4f(0.5f, -0.5f, 0.5f) + offset, yellow));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	// Left
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(-0.5f, -0.5f, -0.5f) + offset, orange));
	vertices.push_back(Vertex(Vector4f(-0.5f, -0.5f, 0.5f) + offset, orange));
	vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, -0.5f) + offset, orange));
	vertices.push_back(Vertex(Vector4f(-0.5f, 0.5f, 0.5f) + offset, orange));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	// Right
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.5f, -0.5f, 0.5f) + offset, pink));
	vertices.push_back(Vertex(Vector4f(0.5f, -0.5f, -0.5f) + offset, pink));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, 0.5f) + offset, pink));
	vertices.push_back(Vertex(Vector4f(0.5f, 0.5f, -0.5f) + offset, pink));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);*/
	
	
	
	/*vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f) + offset, blue));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f) + offset, blue));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f) + offset, blue));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f) + offset, blue));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f) + offset, blue));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f) + offset, blue));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f) + offset, red));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f) + offset, red));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f) + offset, red));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f) + offset, red));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f) + offset, red));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f) + offset, red));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f) + offset, green));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f) + offset, green));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f) + offset, green));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f) + offset, green));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f) + offset, green));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f) + offset, green));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f) + offset, yellow));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f) + offset, yellow));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f) + offset, yellow));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f) + offset, yellow));
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f) + offset, yellow));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f) + offset, yellow));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f) + offset, orange));
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f) + offset, orange));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f) + offset, orange));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f) + offset, orange));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f) + offset, orange));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f) + offset, orange));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f) + offset, pink));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f) + offset, pink));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f) + offset, pink));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f) + offset, pink));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f) + offset, pink));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f) + offset, pink));
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = transMatrix * vertices[i].m_pos;
	}
	renderer.drawTriangleStrip(vertices);*/
	
	const Matrix44 finalTransMatrix = (usePerspective ? persMatrix : MathUtils::CreateIdentityMatrix()) * translationMatrix * rotationMatrix * scaleMatrix;
	
	const Vector2f topLeft(0, 0);
	const Vector2f topRight(1.0f, 0);
	const Vector2f bottomLeft(0, 1.0f);
	const Vector2f bottomRight(1.0f, 1.0f);
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f), topRight));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f), bottomRight));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f), topLeft));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f), bottomRight));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f), bottomLeft));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f), topLeft));
	
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f), bottomRight));
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f), topRight));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f), topLeft));
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f), bottomRight));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f), topLeft));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f), bottomLeft));
	
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = finalTransMatrix * vertices[i].m_pos;
	}
	
	renderer.bindTexture(avatarTexId);
	renderer.drawTriangles(vertices);
	renderer.unbindTexture();
	
	vertices.clear();
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f), red));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f), red));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f), red));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f), red));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f), red));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f), red));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f), green));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f), green));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f), green));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -1.25f, 1.0f), green));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f), green));
	vertices.push_back(Vertex(Vector4f(-0.25f,  0.25f, -2.75f, 1.0f), green));
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f), yellow));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f), yellow));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f), yellow));
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -1.25f, 1.0f), yellow));
	vertices.push_back(Vertex(Vector4f(0.25f,  0.25f, -2.75f, 1.0f), yellow));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f), yellow));
	
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f), pink));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f), pink));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -1.25f, 1.0f), pink));
	vertices.push_back(Vertex(Vector4f(0.25f, -0.25f, -2.75f, 1.0f), pink));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -2.75f, 1.0f), pink));
	vertices.push_back(Vertex(Vector4f(-0.25f, -0.25f, -1.25f, 1.0f), pink));
	
	for (int i = 0; i < vertices.size(); ++i)
	{
		vertices[i].m_pos = finalTransMatrix * vertices[i].m_pos;
	}
	
	renderer.drawTriangles(vertices);
	
	const vec2 p0 = vmake(0, 0);
	const vec2 p1 = vmake(G_WIDTH,G_HEIGHT);
	
	glBindTexture(GL_TEXTURE_2D, openGLTexId);
	glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, renderer.getFrameBuffer());
	glBegin(GL_QUADS);
	glTexCoord2d(0.0, 0.0); glVertex2f(p0.x, p0.y);
	glTexCoord2d(1.0, 0.0); glVertex2f(p1.x, p0.y);
	glTexCoord2d(1.0, 1.0); glVertex2f(p1.x, p1.y);
	glTexCoord2d(0.0, 1.0); glVertex2f(p0.x, p1.y);
	glEnd();
	glBindTexture(GL_TEXTURE_2D, 0);
}

//-----------------------------------------------------------------------------
void RunGame()
{
}

//-----------------------------------------------------------------------------
void ProcessInput()
{
	const bool left = SYS_KeyPressed(SYS_KEY_LEFT);
	const bool right = SYS_KeyPressed(SYS_KEY_RIGHT);
	const bool up = SYS_KeyPressed(SYS_KEY_UP);
	const bool down = SYS_KeyPressed(SYS_KEY_DOWN);
	const bool scaleUp = SYS_KeyPressed('W');
	const bool scaleDown = SYS_KeyPressed('S');
	const bool rotateCCW = SYS_KeyPressed('A');
	const bool rotateCW = SYS_KeyPressed('D');
	const bool swPerspective = SYS_KeyPressed('P');
	const bool swWireframe = SYS_KeyPressed('1');
	const bool swBackFaceCulling = SYS_KeyPressed('2');
	
	if (rotateCW)
	{
		rotationDeg -= 1.0f;
		if (rotationDeg < 0)
		{
			rotationDeg = 360.0f;
		}
		printf("\nRotation: %.1f", rotationDeg);
	}
	else if (rotateCCW)
	{
		rotationDeg += 1.0f;
		if (rotationDeg > 360.0f)
		{
			rotationDeg = 0;
		}
		printf("\nRotation: %.1f", rotationDeg);
	}
	
	if (scaleUp)
	{
		scale += 0.01f;
		printf("\nScale: %.1f", scale);
	}
	else if (scaleDown)
	{
		scale -= 0.01f;
		printf("\nScale: %.1f", scale);
	}
	
	const float kOffsetInc = 0.01f;
	
	if (left)
	{
		posOffset.x -= kOffsetInc;
	}
	
	if (right)
	{
		posOffset.x += kOffsetInc;
	}
	
	if (up)
	{
		posOffset.y += kOffsetInc;
	}
	
	if (down)
	{
		posOffset.y -= kOffsetInc;
	}
	
	if (swPerspective && !keyPressedLastFrame)
	{
		usePerspective = !usePerspective;
		
		if (usePerspective)
		{
			printf("\nProjection: Perspective");
		}
		else
		{
			printf("\nProjection: Orthogonal");
		}
	}
	
	if (swWireframe && !keyPressedLastFrame)
	{
		renderer.setWireFrameModeEnabled(!renderer.getWireFrameModeEnabled());
		printf("\nWireframe mode: %d", renderer.getWireFrameModeEnabled());
	}
	
	if (swBackFaceCulling && !keyPressedLastFrame)
	{
		renderer.setBackFaceCullingEnabled(!renderer.getBackFaceCullingEnabled());
		printf("\nBack face culling enabled: %d", renderer.getBackFaceCullingEnabled());
	}
	
	keyPressedLastFrame = up || down || left || right || scaleUp || scaleDown || rotateCW || rotateCCW || swPerspective || swWireframe || swBackFaceCulling;
}

//-----------------------------------------------------------------------------
// Game state (apart from entities & other stand-alone modules)
float g_time = 0.f;

//-----------------------------------------------------------------------------
// Main
int Main(void)
{
	// Start things up & load resources ---------------------------------------------------
	StartGame();
	
	// Set up rendering ---------------------------------------------------------------------
	glViewport(0, 0, SYS_WIDTH, SYS_HEIGHT);
	glClearColor( 0.0f, 0.1f, 0.3f, 0.0f );
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0.0, G_WIDTH, 0.0, G_HEIGHT, 0.0, 1.0);
	glEnable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	
	// Main game loop! ======================================================================
	while (!SYS_GottaQuit())
	{
		const clock_t startTime = clock();
		Render();
		ProcessInput();
		RunGame();
		SYS_Show();
		SYS_Pump();
		g_time += 1.f/60.f;
		const clock_t endTime = clock();
		//printf("\nFPS: %.1f", 1/(((float)(endTime - startTime)) / CLOCKS_PER_SEC));
	}
	EndGame();
	
	return 0;
}